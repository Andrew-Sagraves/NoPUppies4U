c0ab5045 (asagrave 2025-09-25 08:07:33 -0400   1) #include "asagrave.h"
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400   2) #include <dirent.h>
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400   3) #include <filesystem>
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400   4) #include <fstream>
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400   5) #include <iostream>
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400   6) #include <sstream>
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400   7) #include <string>
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400   8) #include <sys/stat.h>
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400   9) #include <sys/types.h>
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  10) #include <unistd.h>
8c97c913 (asagrave 2025-09-25 08:50:16 -0400  11) #include <unordered_map>
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  12) #include <vector>
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  15) 
fbd494b5 (asagrave 2025-09-25 08:37:20 -0400  16) // Retrieve PATH entries as a vector of strings
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  17) std::vector<std::string> get_paths() {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  18)   std::vector<std::string> paths;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  19)   const char *path_env = getenv("PATH");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  20)   if (!path_env)
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  21)     return paths;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  22) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  23)   std::string path_str(path_env);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  24)   std::stringstream ss(path_str);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  25)   std::string dir;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  26)   while (std::getline(ss, dir, ':')) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  27)     paths.push_back(dir); // keep empty entries (treated as ".")
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  28)   }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  29)   return paths;
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  30) }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  31) 
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  32) // Check if a directory (and its parents) are world-writable
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  33) bool pathutil_is_world_writable_dir(const std::string &dir) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  34)   if (dir.empty())
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  35)     return false;
d5396114 (asagrave 2025-09-25 08:41:38 -0400  36) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  37)   std::string path = dir;
d5396114 (asagrave 2025-09-25 08:41:38 -0400  38) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  39)   // Remove trailing slashes
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  40)   while (path.length() > 1 && path.back() == '/') {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  41)     path.pop_back();
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  42)   }
d5396114 (asagrave 2025-09-25 08:41:38 -0400  43) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  44)   struct ::stat st;
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  45) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  46)   while (!path.empty()) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  47)     if (stat(path.c_str(), &st) == -1)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  48)       return false;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  49)     if (S_ISDIR(st.st_mode) && (st.st_mode & S_IWOTH))
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  50)       return true;
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  51) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  52)     if (path == "/")
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  53)       break; // root reached
d5396114 (asagrave 2025-09-25 08:41:38 -0400  54) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  55)     auto pos = path.find_last_of('/');
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  56)     if (pos == std::string::npos)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  57)       break;
d5396114 (asagrave 2025-09-25 08:41:38 -0400  58) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  59)     if (pos == 0)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  60)       path = "/";
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  61)     else
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  62)       path = path.substr(0, pos);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  63)   }
d5396114 (asagrave 2025-09-25 08:41:38 -0400  64) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  65)   return false;
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  66) }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  67) 
8c97c913 (asagrave 2025-09-25 08:50:16 -0400  68) // Check if directory string is relative
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  69) bool pathutil_is_relative_dir(const std::string &dir) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  70)   if (dir.empty() || dir == ".")
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  71)     return true;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  72)   return dir[0] != '/';
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  73) }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  74) 
8c97c913 (asagrave 2025-09-25 08:50:16 -0400  75) // Check if a directory or its files have vulnerabilities
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  76) PathVulnResult pathutil_dir_has_vulnerability(const std::string &dir) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  77)   std::string effective = dir.empty() ? "." : dir;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  78) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  79)   if (pathutil_is_relative_dir(effective)) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  80)     return {true, "Relative directory"};
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  81)   }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  82) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  83)   if (pathutil_is_world_writable_dir(effective)) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  84)     return {true, "World-writable directory (or parent)"};
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  85)   }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400  86) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  87)   // Scan files inside the directory for world-writable files
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  88)   DIR *dp = opendir(effective.c_str());
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  89)   if (!dp)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  90)     return {false, ""};
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  91) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  92)   struct dirent *entry;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  93)   struct ::stat st;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  94)   std::string filepath;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  95) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  96)   while ((entry = readdir(dp)) != nullptr) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  97)     filepath = effective + "/" + entry->d_name;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  98)     if (stat(filepath.c_str(), &st) == -1)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400  99)       continue;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 100)     if (S_ISREG(st.st_mode) && (st.st_mode & S_IWOTH)) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 101)       closedir(dp);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 102)       return {true, "World-writable file: " + filepath};
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 103)     }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 104)   }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 105) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 106)   closedir(dp);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 107)   return {false, ""};
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 108) }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 109) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 110) // Scan PATH entries and log vulnerabilities, including duplicate executables
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 111) int get_path_vulnerabilities(const std::vector<std::string> &paths) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 112)   std::ofstream report("PATH.txt");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 113)   int problems = 0;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 114) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 115)   // Map to track executable names -> first directory seen
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 116)   std::unordered_map<std::string, std::string> exe_map;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 117) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 118)   for (const auto &dir : paths) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 119)     PathVulnResult result = pathutil_dir_has_vulnerability(dir);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 120)     if (result.vulnerable) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 121)       report << "[!] " << result.reason << " (" << (dir.empty() ? "." : dir)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 122)              << ")\n";
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 123)       problems++;
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 124)     }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 125) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 126)     // Scan executables for duplicates
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 127)     std::string effective = dir.empty() ? "." : dir;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 128)     DIR *dp = opendir(effective.c_str());
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 129)     if (!dp)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 130)       continue;
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 131) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 132)     struct dirent *entry;
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 133)     struct ::stat st;
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 134)     std::string filepath;
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 135) 
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 136)     while ((entry = readdir(dp)) != nullptr) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 137)       filepath = effective + "/" + entry->d_name;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 138)       if (stat(filepath.c_str(), &st) == -1)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 139)         continue;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 140) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 141)       if (S_ISREG(st.st_mode) && (st.st_mode & S_IXUSR)) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 142)         std::string exe_name = entry->d_name;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 143)         if (exe_map.find(exe_name) != exe_map.end()) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 144)           report << "[!] Duplicate executable: " << exe_name << " found in "
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 145)                  << effective << " (also in " << exe_map[exe_name] << ")\n";
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 146)           problems++;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 147)         } else {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 148)           exe_map[exe_name] = effective;
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 149)         }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 150)       }
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 151)     }
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 152) 
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 153)     closedir(dp);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 154)   }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 155) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 156)   report.close();
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 157)   return problems;
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 158) }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 159) // --------------------------------------------------------------
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 160) // Utility functions
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 161) // --------------------------------------------------------------
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 162) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 164) void ensure_dir(const std::string& path) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 165)     struct stat st;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 166)     if (stat(path.c_str(), &st) != 0) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 167)         mkdir(path.c_str(), 0755);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 168)     }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 169) }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 170) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 171) // Append a line to a log file
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 172) void write_log(const std::string& file, const std::string& message) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 173)     std::ofstream out(file.c_str(), std::ios::app);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 174)     if (out.is_open()) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 175)         out << message << "\n";
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 176)     }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 177) }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 178) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 179) // Simple recursive directory traversal using POSIX API
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 180) void list_files_recursive(const std::string& base, std::vector<std::string>& files) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 181)     DIR* dir = opendir(base.c_str());
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 182)     if (!dir) return;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 183) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 184)     struct dirent* entry;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 185)     while ((entry = readdir(dir)) != NULL) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 186)         if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 187)             continue;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 188) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 189)         std::string fullpath = base + "/" + entry->d_name;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 190)         struct stat st;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 191)         if (lstat(fullpath.c_str(), &st) == 0) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 192)             if (S_ISDIR(st.st_mode)) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 193)                 list_files_recursive(fullpath, files);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 194)             } else if (S_ISREG(st.st_mode)) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 195)                 files.push_back(fullpath);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 196)             }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 197)         }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 198)     }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 199)     closedir(dir);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 200) }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 201) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 202) // --------------------------------------------------------------
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 203) // 1. Passwordless sudo access check
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 204) // --------------------------------------------------------------
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 205) bool passwordless_sudo_access(const std::string& logDir) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 206)     std::string logFile = logDir + "/sudo_audit.log";
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 207)     write_log(logFile, "=== Checking for passwordless SUDO access ===");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 208) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 209)     bool found = false;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 210)     const char* username = getenv("USER");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 211)     if (!username) username = "UNKNOWN";
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 212) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 213)     std::vector<std::string> sudoFiles;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 214)     sudoFiles.push_back("/etc/sudoers");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 215) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 216)     // Include any files under /etc/sudoers.d
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 217)     DIR* d = opendir("/etc/sudoers.d");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 218)     if (d) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 219)         struct dirent* e;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 220)         while ((e = readdir(d)) != NULL) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 221)             if (e->d_name[0] == '.') continue;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 222)             sudoFiles.push_back(std::string("/etc/sudoers.d/") + e->d_name);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 223)         }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 224)         closedir(d);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 225)     }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 226) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 227)     for (size_t i = 0; i < sudoFiles.size(); ++i) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 228)         std::ifstream in(sudoFiles[i].c_str());
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 229)         if (!in.is_open()) continue;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 230) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 231)         std::string line;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 232)         while (std::getline(in, line)) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 233)             if (line.find("NOPASSWD") != std::string::npos &&
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 234)                 (line.find(username) != std::string::npos || line.find("ALL") != std::string::npos)) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 235)                 found = true;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 236)                 write_log(logFile, "Passwordless sudo entry found in: " + sudoFiles[i]);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 237)                 write_log(logFile, "  -> " + line);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 238)             }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 239)         }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 240)     }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 241) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 242)     if (!found)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 243)         write_log(logFile, "No passwordless sudo entries found.");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 244) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 245)     return found;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 246) }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 247) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 248) // --------------------------------------------------------------
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 249) // 2. World-writable SSH keys
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 250) // --------------------------------------------------------------
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 251) bool world_writable_ssh_keys(const std::string& logDir) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 252)     std::string logFile = logDir + "/ssh_key_audit.log";
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 253)     write_log(logFile, "=== Checking for world-writable SSH keys ===");
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 254) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 255)     bool found = false;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 256)     std::vector<std::string> sshDirs;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 257) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 258)     const char* home = getenv("HOME");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 259)     if (home) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 260)         sshDirs.push_back(std::string(home) + "/.ssh");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 261)     }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 262)     sshDirs.push_back("/etc/ssh");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 263) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 264)     for (size_t i = 0; i < sshDirs.size(); ++i) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 265)         std::vector<std::string> files;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 266)         list_files_recursive(sshDirs[i], files);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 267)         for (size_t j = 0; j < files.size(); ++j) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 268)             struct stat st;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 269)             if (stat(files[j].c_str(), &st) == 0) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 270)                 if (st.st_mode & S_IWOTH) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 271)                     found = true;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 272)                     write_log(logFile, "World-writable SSH file: " + files[j]);
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 273)                 }
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 274)             }
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 275)         }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 276)     }
8c97c913 (asagrave 2025-09-25 08:50:16 -0400 277) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 278)     if (!found)
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 279)         write_log(logFile, "No world-writable SSH keys found.");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 280) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 281)     return found;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 282) }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 283) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 284) // --------------------------------------------------------------
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 285) // 3. SUID binary audit
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 286) // --------------------------------------------------------------
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 287) bool suid_binary_audit(const std::string& logDir) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 288)     std::string logFile = logDir + "/suid_audit.log";
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 289)     write_log(logFile, "=== Scanning for SUID binaries ===");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 290) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 291)     bool found = false;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 292)     int count = 0;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 293) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 294)     std::vector<std::string> dirs;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 295)     dirs.push_back("/bin");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 296)     dirs.push_back("/sbin");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 297)     dirs.push_back("/usr/bin");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 298)     dirs.push_back("/usr/sbin");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 299)     dirs.push_back("/usr/local/bin");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 300)     dirs.push_back("/usr/local/sbin");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 301)     dirs.push_back("/opt");
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 302) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 303)     for (size_t i = 0; i < dirs.size(); ++i) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 304)         std::vector<std::string> files;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 305)         list_files_recursive(dirs[i], files);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 306)         for (size_t j = 0; j < files.size(); ++j) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 307)             struct stat st;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 308)             if (lstat(files[j].c_str(), &st) == 0) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 309)                 if (st.st_mode & S_ISUID) {
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 310)                     found = true;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 311)                     count++;
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 312)                     write_log(logFile, "SUID binary: " + files[j]);
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 313)                 }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 314)             }
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 315)         }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 316)     }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 317) 
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 318)     write_log(logFile, "Total SUID binaries found: " + std::to_string(count));
ccebbb88 (asagrave 2025-10-13 18:05:10 -0400 319)     return found;
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 320) }
c0ab5045 (asagrave 2025-09-25 08:07:33 -0400 321) 
